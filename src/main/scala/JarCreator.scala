import Models.*
import com.jamesward.zio_mavencentral.MavenCentral
import zio.*
import zio.compress.*
import zio.stream.*

import java.io.File
import java.nio.file.Files
//import scala.jdk.CollectionConverters.*

object JarCreator:

  def create(
    skillDir: File,
    org: Org,
    repo: Repo,
    path: List[String],
    pom: Chunk[Byte],
    groupId: MavenCentral.GroupId,
    artifactId: MavenCentral.ArtifactId,
    version: MavenCentral.Version,
  ): IO[DeployError, Chunk[Byte]] =
    val pathPart = if path.isEmpty then "" else path.mkString("", "/", "/")
    val resourcePrefix = s"META-INF/skills/$org/$repo/$pathPart"
    val mavenPrefix = s"META-INF/maven/$groupId/$artifactId/"

    val manifestContent =
      """Manifest-Version: 1.0
        |Created-By: skillsjars.com
        |""".stripMargin

    val properties =
      s"""#Generated by SkillsJars
         |version=$version
         |groupId=$groupId
         |artifactId=$artifactId
         |""".stripMargin

    def chunkEntry(name: String, content: Chunk[Byte]): (ArchiveEntry[Option, Any], ZStream[Any, Throwable, Byte]) =
      (ArchiveEntry(name = name), ZStream.fromChunk(content))

    def dirEntry(name: String): (ArchiveEntry[Option, Any], ZStream[Any, Throwable, Byte]) =
      (ArchiveEntry(name = name, isDirectory = true), ZStream.empty)

    val skillFileEntries = ZStream.fromJavaStream(Files.walk(skillDir.toPath))
      .mapError(e => DeployError.PublishFailed(s"Failed to list skill files: ${e.getMessage}"))
      .filterZIO(path => ZIO.attempt(!Files.isSameFile(path, skillDir.toPath)).orDie)
      .filter: path =>
        val relative = skillDir.toPath.relativize(path).toString.replace('\\', '/')
        !relative.startsWith(".git")
      .mapZIO: path =>
        ZIO.attempt:
          val relative = skillDir.toPath.relativize(path).toString.replace('\\', '/')
          if Files.isDirectory(path) then
            dirEntry(s"$resourcePrefix$relative/")
          else
            (ArchiveEntry(name = s"$resourcePrefix$relative"), ZStream.fromPath(path))
        .mapError: (e: DeployError | Throwable) =>
          e match
            case de: DeployError => de
            case t: Throwable => DeployError.PublishFailed(s"Failed to read skill file $path: ${t.getMessage}")

    def parentDirs(path: String): List[String] =
      val segments = path.stripSuffix("/").split('/').toList
      segments.indices.drop(1).map(i => segments.take(i).mkString("", "/", "/")).toList

    val dirEntries = ZStream.fromIterable(
      (parentDirs(resourcePrefix) ++ parentDirs(mavenPrefix)).distinct.map(dirEntry)
    )

    val staticEntries = ZStream(
      chunkEntry("META-INF/MANIFEST.MF", Chunk.fromArray(manifestContent.getBytes)),
      chunkEntry(s"${mavenPrefix}pom.xml", pom),
      chunkEntry(s"${mavenPrefix}pom.properties", Chunk.fromArray(properties.getBytes))
    )

    (dirEntries ++ staticEntries ++ skillFileEntries)
      .via(ZipArchiver.archive)
      .runCollect
      .mapError: (e: DeployError | Throwable) =>
        e match
          case de: DeployError => de
          case t: Throwable => DeployError.PublishFailed(s"JAR creation failed: ${t.getMessage}")
